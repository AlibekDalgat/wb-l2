package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"os"
	"strconv"
)

/*
=== Задача на распаковку ===

Создать Go функцию, осуществляющую примитивную распаковку строки, содержащую повторяющиеся символы / руны, например:
	- "a4bc2d5e" => "aaaabccddddde"
	- "abcd" => "abcd"
	- "45" => "" (некорректная строка)
	- "" => ""
Дополнительное задание: поддержка escape - последовательностей
	- qwe\4\5 => qwe45 (*)
	- qwe\45 => qwe44444 (*)
	- qwe\\5 => qwe\\\\\ (*)

В случае если была передана некорректная строка функция должна возвращать ошибку. Написать unit-тесты.

Функция должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

func runeRepeat(buf *bytes.Buffer, r rune, n int) {
	for i := 0; i < n; i++ {
		buf.WriteRune(r)
	}
}

func unpacking(inputRunes []rune) (string, error) {
	var (
		sym, r rune
		esc    bool
		buffer bytes.Buffer // результиирующий буфер в который удобно конкатинировать символы
	)
	// проход по каждой руне
	for i := 0; i < len(inputRunes); i++ {
		r = inputRunes[i]
		// попытка перевода руны в число
		num, err := strconv.Atoi(string(r))
		// если руна является числом и приэтом предыдущая руна не является символом, которую нужно распаковать, вернуть ошибку
		if sym == 0 && err == nil && !esc {
			return "", errors.New("некорректная строка")
		}
		// если предыдущая руна не явлется символом, данная руна явлется обратным слешом и экранирующего слеша ещё не виднелась,
		//задать данный слэш экранирующем
		if sym == 0 && r == '\\' && !esc {
			esc = true
		} else if esc || sym == 0 { // если экранирующий слеш попадался или символа нет, задать текущий рун символом, задать экранирующий слеш недействительным
			sym, esc = r, false
		} else if sym != 0 && err == nil { // если символ существует и результат конвертации текущей руны положительный,
			// добавить символы в буфер. задать символ num раз и экранирующий слеш несущесвтующий
			runeRepeat(&buffer, sym, num)
			sym, esc = 0, false
		} else { // иначе добавить существующий символ и остаться на текущем руне
			//задать символ num раз и экранирующий слеш несущесвтующий
			buffer.WriteRune(sym)
			sym, esc = 0, false
			i--
		}
	}
	// последний рун необработан. дообробатывание
	if sym != 0 {
		buffer.WriteRune(sym)
	}
	// возвращение содержимого буфера и пустой ошибки
	return buffer.String(), nil
}

func main() {
	// сканер для чтения ввода включая пустые строки
	myscanner := bufio.NewScanner(os.Stdin)
	myscanner.Scan()
	line := myscanner.Text()
	// запуск функции распаковки
	res, err := unpacking([]rune(line))
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(res)
	}
}
